require 'nostrb'

module Nostr
  class Event
    # id: 64 hex chars (32B binary)
    # pubkey: 64 hex chars (32B binary)
    # created_at: unix seconds, integer
    # kind: 0..65535
    # tags: Array[Array[string]]
    # content: any string
    # sig: 128 hex chars (64B binary)

    # the id is a SHA256 digest of the serialized event:
    # [ 0,
    #   <pubkey, lowercase hex>,
    #   <created at>,
    #   <kind>,
    #   <tags>,
    #   <content> ]

    # Event Creation
    # ---
    # 1. given: content, public key, kind, (tags)
    # 2. generate timestamp: Integer, unix timestamp
    # 3. generate id: SHA256, 32B binary, 64B hex
    # 4. sign(secret_key): 64B binary, 128B hex

    class Error < RuntimeError; end
    class BoundsError < Error; end
    class FrozenError < Error; end
    class IdCheck < Error; end
    class SignatureCheck < Error; end

    # deconstruct and typecheck, return a ruby hash
    # this should correspond directly to Event#to_h
    # may raise explicitly: KeyError on Hash#fetch
    # may raise implicitly: Nostr::SizeError, EncodingError, TypeError
    def self.hash(json_str)
      h = Nostr.parse(json_str)
      Nostr.check!(h, Hash)
      Hash[id:            Nostr.text!(h.fetch("id"), 64),
           pubkey:        Nostr.text!(h.fetch("pubkey"), 64),
           kind:       Nostr.integer!(h.fetch("kind")),
           content:       Nostr.text!(h.fetch("content")),
           tags:          Nostr.tags!(h.fetch("tags")),
           created_at: Nostr.integer!(h.fetch("created_at")),
           sig:           Nostr.text!(h.fetch("sig"), 128),
          ]
    end

    # create JSON array serialization
    # this should correspond directly to Event#serialize and Event#to_s
    # may raise KeyError on Hash#fetch
    def self.serialize(hash)
      # The inbound hash is presumably valid, having been generated by
      # Event.hash above, but fetch the keys anyways for a sanity check
      Nostr.json([0,
                  hash.fetch(:pubkey),
                  hash.fetch(:created_at),
                  hash.fetch(:kind),
                  hash.fetch(:tags),
                  hash.fetch(:content),])
    end

    # validate the id (optional) and signature
    # may raise explicitly: IdCheck, SignatureCheck
    # may raise implicitly: Nostr::SizeError, EncodingError, TypeError,
    #                       SchnorrSig::Error
    # return a _completely validated_ hash
    def self.verify(json_str, check_id: true)
      # validate the json string; we know we have a valid hash now
      h = self.hash(json_str)

      # extract binary values for signature verification
      digest = SchnorrSig.hex2bin(h[:id])
      pk = SchnorrSig.hex2bin(h[:pubkey])
      signature = SchnorrSig.hex2bin(h[:sig])

      # (optional) verify the id / digest
      if check_id and digest != Nostr.digest(self.serialize(h))
        raise(IdCheck, h[:id])
      end

      # verify the signature
      unless SchnorrSig.verify?(pk, digest, signature)
        raise(SignatureCheck, h[:sig])
      end
      h
    end

    attr_reader :content, :pubkey, :kind, :tags,
                :created_at, :id, :signature
    attr_accessor :max_tags

    # pubkey: required
    def initialize(content = '', pubkey:, kind: 1)
      @content = Nostr.text!(content)
      @kind = Nostr.integer!(kind)
      @pubkey = Nostr.text!(pubkey, 64)
      @tags = []
      @created_at = nil
      @id = nil
      @signature = nil
      @max_tags = 99
    end

    # always reset @created_at to the current time
    # return ruby array corresponding to NIP-01 serialization
    def serialize
      @created_at = Time.now.to_i
      [0, @pubkey, @created_at, @kind, @tags, @content]
    end

    # NIP-01 serialization in JSON form
    # return string
    def to_s
      Nostr.json(self.serialize)
    end

    # compute SHA256 digest for the current moment
    def digest
      Nostr.digest(self.to_s)
    end

    # return a Ruby hash, suitable for JSON conversion to NIPS01 Event object
    def to_h
      Hash[id: @id,
           pubkey: @pubkey,
           created_at: @created_at || Time.now.to_i,
           kind: @kind,
           tags: @tags,
           content: @content,
           sig: self.sig,
          ]
    end

    # before signing, return the array serialization
    # after signing, return the full object
    def to_json
      @signature ? Nostr.json(self.to_h) : self.to_s
    end

    # secret key is 64 bytes hex
    # assign @signature, 64 bytes binary
    # signing will reset created_at and thus the digest / id
    # return self
    def sign(secret_key)
      # fail early if we don't like the secret_key
      sk = SchnorrSig.hex2bin(Nostr.text!(secret_key, 64))
      # this value is critical for the @id and @signature
      d = self.digest # resets @created_at
      # attempt signing
      @signature = SchnorrSig.sign(sk, d)
      # set the @id if we've gotten this far
      @id = SchnorrSig.bin2hex(d)
      self
    end

    def signed?
      !!@signature
    end

    # nil unless signed
    # return 128 bytes hex encoded
    def sig
      SchnorrSig.bin2hex(@signature) if @signature
    end

    # add an array of 2+ strings to @tags
    def add_tag(tag, value, *rest)
      raise(FrozenError) if signed?
      if tags.length >= @max_tags
        raise(SizeError, "max tags (#{@max_tags}) reached")
      end
      @digest = nil # invalidate any prior digest
      @tags.push([Nostr.text!(tag), Nostr.text!(value)] +
                 rest.each { |s| Nostr.text!(s) })
    end

    # add an event tag based on event id, hex encoded
    def ref_event(eid_hex, *rest)
      add_tag('e', Nostr.text!(eid_hex, 64), *rest)
    end

    # add a pubkey tag based on pubkey, 64 bytes hex encoded
    def ref_pubkey(pubkey, *rest)
      add_tag('p', Nostr.text!(pubkey, 64), *rest)
    end

    # kind: and pubkey: required
    def ref_replace(*rest, kind:, pubkey:, d_tag: '')
      val = [Nostr.integer!(kind), Nostr.text!(pubkey, 64), d_tag].join(':')
      add_tag('a', val, *rest)
    end
  end
end
