require 'nostrb'

module Nostr
  class Event
    # id: 64 hex chars (32B binary)
    # pubkey: 64 hex chars (32B binary)
    # created_at: unix seconds, integer
    # kind: 0..65535
    # tags: Array[Array[string]]
    # content: any string
    # sig: 128 hex chars (64B binary)

    # the id is a SHA256 digest of the serialized event:
    # [ 0,
    #   <pubkey, lowercase hex>,
    #   <created at>,
    #   <kind>,
    #   <tags>,
    #   <content> ]

    # Event Creation
    # ---
    # 1. given: content, public key, kind, (tags)
    # 2. generate timestamp: Integer, unix timestamp
    # 3. generate id: SHA256, 32B binary, 64B hex
    # 4. sign(secret_key): 64B binary, 128B hex

    class Error < RuntimeError; end
    class BoundsError < Error; end
    class FrozenError < Error; end
    class IdCheck < Error; end
    class SignatureCheck < Error; end

    # Deconstruct and typecheck, return a ruby hash
    # This should correspond directly to Event#to_h
    # May raise explicitly: KeyError on Hash#fetch
    # May raise implicitly: Nostr::SizeError, EncodingError, TypeError
    def self.hash(json_str)
      h = Nostr.parse(json_str)
      Nostr.check!(h, Hash)
      Hash[ id:        Nostr.text!(h.fetch("id"), 64),
            pubkey:    Nostr.text!(h.fetch("pubkey"), 64),
            kind:       Nostr.int!(h.fetch("kind")),
            content:   Nostr.text!(h.fetch("content")),
            tags:      Nostr.tags!(h.fetch("tags")),
            created_at: Nostr.int!(h.fetch("created_at")),
            sig:       Nostr.text!(h.fetch("sig"), 128),
          ]
    end

    # Create JSON array serialization
    # This should correspond directly to Event#serialize and Event#to_s
    # May raise KeyError on Hash#fetch
    def self.serialize(hash)
      # The inbound hash is presumably valid, having been generated by
      # Event.hash above, but fetch the keys anyways for a sanity check
      Nostr.json([0,
                  hash.fetch(:pubkey),
                  hash.fetch(:created_at),
                  hash.fetch(:kind),
                  hash.fetch(:tags),
                  hash.fetch(:content),])
    end

    # Validate the id (optional) and signature
    # May raise explicitly: IdCheck, SignatureCheck
    # May raise implicitly: Nostr::SizeError, EncodingError, TypeError,
    #                       SchnorrSig::Error
    # Return a _completely validated_ hash
    def self.verify(json_str, check_id: true)
      # validate the json string; we know we have a valid hash now
      h = self.hash(json_str)

      # extract binary values for signature verification
      digest = SchnorrSig.hex2bin(h[:id])
      pk = SchnorrSig.hex2bin(h[:pubkey])
      signature = SchnorrSig.hex2bin(h[:sig])

      # (optional) verify the id / digest
      if check_id and digest != Nostr.digest(self.serialize(h))
        raise(IdCheck, h[:id])
      end

      # verify the signature
      unless SchnorrSig.verify?(pk, digest, signature)
        raise(SignatureCheck, h[:sig])
      end
      h
    end

    attr_reader :content, :pubkey, :kind, :tags,
                :created_at, :id, :signature
    attr_accessor :max_tags

    # pubkey: required
    def initialize(content = '', pubkey:, kind: 1)
      @content = Nostr.text!(content)
      @kind = Nostr.int!(kind)
      @pubkey = Nostr.text!(pubkey, 64)
      @tags = []
      @created_at = Time.now.to_i
      @id = ""
      @signature = "".b
      @max_tags = 99
    end

    # Always reset @created_at to the current time
    # Return ruby array corresponding to NIP-01 serialization
    def serialize
      @created_at = Time.now.to_i
      [0, @pubkey, @created_at, @kind, @tags, @content]
    end

    # NIP-01 serialization in JSON form; return string
    def to_s = Nostr.json(self.serialize)

    # Compute SHA256 digest for the current moment
    def digest = Nostr.digest(self.to_s)

    # Return a Ruby hash
    # If signed, suitable for JSON conversion to NIPS01 Event object
    def to_h
      Hash[ id: @id,
            pubkey: @pubkey,
            created_at: @created_at,
            kind: @kind,
            tags: @tags,
            content: @content,
            sig: self.sig,
          ]
    end

    # Return true or false
    def signed? = !@signature.empty?

    # Return full object if signed, otherwise array serialization
    def to_json = signed? ? Nostr.json(self.to_h) : self.to_s

    # Secret key is 64 bytes hex
    # Assign @signature, 64 bytes binary
    # Signing will reset created_at and thus the digest / id
    # Return self
    def sign(secret_key)
      sk = SchnorrSig.hex2bin(Nostr.text!(secret_key, 64))
      d = self.digest
      @signature = SchnorrSig.sign(sk, d)
      @id = SchnorrSig.bin2hex(d)
      self
    end

    # Return 128 bytes of hex if signed, empty otherwise
    def sig = SchnorrSig.bin2hex(@signature)

    # add an array of 2+ strings to @tags
    def add_tag(tag, value, *rest)
      raise(FrozenError) if signed?
      if tags.length >= @max_tags
        raise(SizeError, "max tags (#{@max_tags}) reached")
      end
      @digest = nil # invalidate any prior digest
      @tags.push([Nostr.text!(tag), Nostr.text!(value)] +
                 rest.each { |s| Nostr.text!(s) })
    end

    # add an event tag based on event id, hex encoded
    def ref_event(eid_hex, *rest)
      add_tag('e', Nostr.text!(eid_hex, 64), *rest)
    end

    # add a pubkey tag based on pubkey, 64 bytes hex encoded
    def ref_pubkey(pubkey, *rest)
      add_tag('p', Nostr.text!(pubkey, 64), *rest)
    end

    # kind: and pubkey: required
    def ref_replace(*rest, kind:, pubkey:, d_tag: '')
      val = [Nostr.int!(kind), Nostr.text!(pubkey, 64), d_tag].join(':')
      add_tag('a', val, *rest)
    end
  end
end
